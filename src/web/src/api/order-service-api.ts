//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class OrderServiceClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param select (optional) Returns only the selected properties. (ex. FirstName, LastName, City)
     * @param expand (optional) Include only the selected objects. (ex. Childrens, Locations)
     * @param filter (optional) Filter the response with OData filter queries.
     * @param top (optional) Number of objects to return. (ex. 25)
     * @param skip (optional) Number of objects to skip in the current order (ex. 50)
     * @param orderby (optional) Define the order by one or more fields (ex. LastModified)
     * @return Success
     */
    getClients(select: string | undefined, expand: string | undefined, filter: string | undefined, top: string | undefined, skip: string | undefined, orderby: string | undefined, cancelToken?: CancelToken): Promise<ClientResponse[]> {
        let url_ = this.baseUrl + "/api/v1/client?";
        if (select === null)
            throw new Error("The parameter 'select' cannot be null.");
        else if (select !== undefined)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "$expand=" + encodeURIComponent("" + expand) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (orderby === null)
            throw new Error("The parameter 'orderby' cannot be null.");
        else if (orderby !== undefined)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetClients(_response);
        });
    }

    protected processGetClients(response: AxiosResponse): Promise<ClientResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ClientResponse[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClientResponse[]>(null as any);
    }

    /**
     * @return Success
     */
    addClient(body: ClientInsert, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/client";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddClient(_response);
        });
    }

    protected processAddClient(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    updateClient(body: ClientUpdate, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/client";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateClient(_response);
        });
    }

    protected processUpdateClient(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    deleteClient(id: string, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/client/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteClient(_response);
        });
    }

    protected processDeleteClient(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getDownloadApp( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/helper/app";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDownloadApp(_response);
        });
    }

    protected processGetDownloadApp(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 302) {
            const _responseText = response.data;
            return throwException("Redirect", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    addMessage(body: MessageInsert, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/helper/message";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddMessage(_response);
        });
    }

    protected processAddMessage(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getCityByCep(cep: string, cancelToken?: CancelToken): Promise<CityResponse> {
        let url_ = this.baseUrl + "/api/v1/localization/city/{cep}";
        if (cep === undefined || cep === null)
            throw new Error("The parameter 'cep' must be defined.");
        url_ = url_.replace("{cep}", encodeURIComponent("" + cep));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCityByCep(_response);
        });
    }

    protected processGetCityByCep(response: AxiosResponse): Promise<CityResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CityResponse.fromJS(resultData200);
            return Promise.resolve<CityResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CityResponse>(null as any);
    }

    /**
     * @param select (optional) Returns only the selected properties. (ex. FirstName, LastName, City)
     * @param expand (optional) Include only the selected objects. (ex. Childrens, Locations)
     * @param filter (optional) Filter the response with OData filter queries.
     * @param top (optional) Number of objects to return. (ex. 25)
     * @param skip (optional) Number of objects to skip in the current order (ex. 50)
     * @param orderby (optional) Define the order by one or more fields (ex. LastModified)
     * @return Success
     */
    getNotifications(select: string | undefined, expand: string | undefined, filter: string | undefined, top: string | undefined, skip: string | undefined, orderby: string | undefined, cancelToken?: CancelToken): Promise<NotificationResponse[]> {
        let url_ = this.baseUrl + "/api/v1/notification?";
        if (select === null)
            throw new Error("The parameter 'select' cannot be null.");
        else if (select !== undefined)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "$expand=" + encodeURIComponent("" + expand) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (orderby === null)
            throw new Error("The parameter 'orderby' cannot be null.");
        else if (orderby !== undefined)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetNotifications(_response);
        });
    }

    protected processGetNotifications(response: AxiosResponse): Promise<NotificationResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NotificationResponse[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NotificationResponse[]>(null as any);
    }

    /**
     * @param select (optional) Returns only the selected properties. (ex. FirstName, LastName, City)
     * @param expand (optional) Include only the selected objects. (ex. Childrens, Locations)
     * @param filter (optional) Filter the response with OData filter queries.
     * @param top (optional) Number of objects to return. (ex. 25)
     * @param skip (optional) Number of objects to skip in the current order (ex. 50)
     * @param orderby (optional) Define the order by one or more fields (ex. LastModified)
     * @return Success
     */
    getOrders(select: string | undefined, expand: string | undefined, filter: string | undefined, top: string | undefined, skip: string | undefined, orderby: string | undefined, cancelToken?: CancelToken): Promise<OrderResponse[]> {
        let url_ = this.baseUrl + "/api/v1/order?";
        if (select === null)
            throw new Error("The parameter 'select' cannot be null.");
        else if (select !== undefined)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "$expand=" + encodeURIComponent("" + expand) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (orderby === null)
            throw new Error("The parameter 'orderby' cannot be null.");
        else if (orderby !== undefined)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrders(_response);
        });
    }

    protected processGetOrders(response: AxiosResponse): Promise<OrderResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OrderResponse[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderResponse[]>(null as any);
    }

    /**
     * @return Success
     */
    addOrder(body: OrderInsert, cancelToken?: CancelToken): Promise<OrderPdfResponse> {
        let url_ = this.baseUrl + "/api/v1/order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddOrder(_response);
        });
    }

    protected processAddOrder(response: AxiosResponse): Promise<OrderPdfResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrderPdfResponse.fromJS(resultData200);
            return Promise.resolve<OrderPdfResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderPdfResponse>(null as any);
    }

    /**
     * @return Success
     */
    getOrderAsPdf(ids: string[], cancelToken?: CancelToken): Promise<OrderPdfResponse> {
        let url_ = this.baseUrl + "/api/v1/order/pdf?";
        if (ids === undefined || ids === null)
            throw new Error("The parameter 'ids' must be defined and cannot be null.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderAsPdf(_response);
        });
    }

    protected processGetOrderAsPdf(response: AxiosResponse): Promise<OrderPdfResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrderPdfResponse.fromJS(resultData200);
            return Promise.resolve<OrderPdfResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderPdfResponse>(null as any);
    }

    /**
     * @return Success
     */
    getOrderDetailById(id: string, cancelToken?: CancelToken): Promise<OrderDetailResponse> {
        let url_ = this.baseUrl + "/api/v1/order/pdf/detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderDetailById(_response);
        });
    }

    protected processGetOrderDetailById(response: AxiosResponse): Promise<OrderDetailResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrderDetailResponse.fromJS(resultData200);
            return Promise.resolve<OrderDetailResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderDetailResponse>(null as any);
    }

    /**
     * @return Success
     */
    getOrderPdfById(id: string, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/order/pdf/document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrderPdfById(_response);
        });
    }

    protected processGetOrderPdfById(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    updateOrderState(ids: string[], state: OrderState, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/order/state?";
        if (ids === undefined || ids === null)
            throw new Error("The parameter 'ids' must be defined and cannot be null.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined and cannot be null.");
        else
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PATCH",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateOrderState(_response);
        });
    }

    protected processUpdateOrderState(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    deleteOrder(id: string, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/order/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteOrder(_response);
        });
    }

    protected processDeleteOrder(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param select (optional) Returns only the selected properties. (ex. FirstName, LastName, City)
     * @param expand (optional) Include only the selected objects. (ex. Childrens, Locations)
     * @param filter (optional) Filter the response with OData filter queries.
     * @param top (optional) Number of objects to return. (ex. 25)
     * @param skip (optional) Number of objects to skip in the current order (ex. 50)
     * @param orderby (optional) Define the order by one or more fields (ex. LastModified)
     * @return Success
     */
    getProducts(select: string | undefined, expand: string | undefined, filter: string | undefined, top: string | undefined, skip: string | undefined, orderby: string | undefined, cancelToken?: CancelToken): Promise<ProductResponse[]> {
        let url_ = this.baseUrl + "/api/v1/product?";
        if (select === null)
            throw new Error("The parameter 'select' cannot be null.");
        else if (select !== undefined)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "$expand=" + encodeURIComponent("" + expand) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (orderby === null)
            throw new Error("The parameter 'orderby' cannot be null.");
        else if (orderby !== undefined)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProducts(_response);
        });
    }

    protected processGetProducts(response: AxiosResponse): Promise<ProductResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ProductResponse[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductResponse[]>(null as any);
    }

    /**
     * @return Success
     */
    addProduct(body: ProductInsert, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddProduct(_response);
        });
    }

    protected processAddProduct(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    updateProduct(body: ProductUpdate, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateProduct(_response);
        });
    }

    protected processUpdateProduct(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    deleteProduct(id: string, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteProduct(_response);
        });
    }

    protected processDeleteProduct(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getUser( cancelToken?: CancelToken): Promise<UserResponse> {
        let url_ = this.baseUrl + "/api/v1/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: AxiosResponse): Promise<UserResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserResponse.fromJS(resultData200);
            return Promise.resolve<UserResponse>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserResponse>(null as any);
    }

    /**
     * @return Success
     */
    updateUser(body: UserUpdate, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json;odata.metadata=minimal;odata.streaming=true",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    deleteAccount( cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAccount(_response);
        });
    }

    protected processDeleteAccount(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    getPictureByUserId(id: string, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/user/picture/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPictureByUserId(_response);
        });
    }

    protected processGetPictureByUserId(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    acceptPrivacyPolicy( cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/user/privacypolicy";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PATCH",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAcceptPrivacyPolicy(_response);
        });
    }

    protected processAcceptPrivacyPolicy(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    updatePushNotificationToken(token: string, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/user/push/token/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PATCH",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePushNotificationToken(_response);
        });
    }

    protected processUpdatePushNotificationToken(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    updateAddPictureInOrder(insert: boolean, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/v1/user/pictureinorder/{insert}";
        if (insert === undefined || insert === null)
            throw new Error("The parameter 'insert' must be defined.");
        url_ = url_.replace("{insert}", encodeURIComponent("" + insert));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PATCH",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAddPictureInOrder(_response);
        });
    }

    protected processUpdateAddPictureInOrder(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class CityResponse implements ICityResponse {
    cep?: string | null;
    uf?: string | null;
    localidade?: string | null;

    constructor(data?: ICityResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cep = _data["cep"] !== undefined ? _data["cep"] : <any>null;
            this.uf = _data["uf"] !== undefined ? _data["uf"] : <any>null;
            this.localidade = _data["localidade"] !== undefined ? _data["localidade"] : <any>null;
        }
    }

    static fromJS(data: any): CityResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CityResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cep"] = this.cep !== undefined ? this.cep : <any>null;
        data["uf"] = this.uf !== undefined ? this.uf : <any>null;
        data["localidade"] = this.localidade !== undefined ? this.localidade : <any>null;
        return data;
    }
}

export interface ICityResponse {
    cep?: string | null;
    uf?: string | null;
    localidade?: string | null;
}

export class ClientInsert implements IClientInsert {
    name?: string | null;
    document?: string | null;
    state?: string | null;
    city?: string | null;
    cep?: string | null;
    cellphone?: string | null;

    constructor(data?: IClientInsert) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.document = _data["document"] !== undefined ? _data["document"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.city = _data["city"] !== undefined ? _data["city"] : <any>null;
            this.cep = _data["cep"] !== undefined ? _data["cep"] : <any>null;
            this.cellphone = _data["cellphone"] !== undefined ? _data["cellphone"] : <any>null;
        }
    }

    static fromJS(data: any): ClientInsert {
        data = typeof data === 'object' ? data : {};
        let result = new ClientInsert();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["document"] = this.document !== undefined ? this.document : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["cep"] = this.cep !== undefined ? this.cep : <any>null;
        data["cellphone"] = this.cellphone !== undefined ? this.cellphone : <any>null;
        return data;
    }
}

export interface IClientInsert {
    name?: string | null;
    document?: string | null;
    state?: string | null;
    city?: string | null;
    cep?: string | null;
    cellphone?: string | null;
}

export class ClientResponse implements IClientResponse {
    id?: string;
    name?: string | null;
    document?: string | null;
    state?: string | null;
    city?: string | null;
    cep?: string | null;
    cellphone?: string | null;
    type?: Person;
    readonly inserted?: Date;

    constructor(data?: IClientResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.document = _data["document"] !== undefined ? _data["document"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.city = _data["city"] !== undefined ? _data["city"] : <any>null;
            this.cep = _data["cep"] !== undefined ? _data["cep"] : <any>null;
            this.cellphone = _data["cellphone"] !== undefined ? _data["cellphone"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            (<any>this).inserted = _data["inserted"] ? new Date(_data["inserted"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): ClientResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClientResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["document"] = this.document !== undefined ? this.document : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["cep"] = this.cep !== undefined ? this.cep : <any>null;
        data["cellphone"] = this.cellphone !== undefined ? this.cellphone : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["inserted"] = this.inserted ? this.inserted.toISOString() : <any>null;
        return data;
    }
}

export interface IClientResponse {
    id?: string;
    name?: string | null;
    document?: string | null;
    state?: string | null;
    city?: string | null;
    cep?: string | null;
    cellphone?: string | null;
    type?: Person;
    inserted?: Date;
}

export class ClientUpdate implements IClientUpdate {
    id?: string;
    name?: string | null;
    document?: string | null;
    state?: string | null;
    city?: string | null;
    cep?: string | null;
    cellphone?: string | null;

    constructor(data?: IClientUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.document = _data["document"] !== undefined ? _data["document"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.city = _data["city"] !== undefined ? _data["city"] : <any>null;
            this.cep = _data["cep"] !== undefined ? _data["cep"] : <any>null;
            this.cellphone = _data["cellphone"] !== undefined ? _data["cellphone"] : <any>null;
        }
    }

    static fromJS(data: any): ClientUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new ClientUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["document"] = this.document !== undefined ? this.document : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["cep"] = this.cep !== undefined ? this.cep : <any>null;
        data["cellphone"] = this.cellphone !== undefined ? this.cellphone : <any>null;
        return data;
    }
}

export interface IClientUpdate {
    id?: string;
    name?: string | null;
    document?: string | null;
    state?: string | null;
    city?: string | null;
    cep?: string | null;
    cellphone?: string | null;
}

export class ErrorDto implements IErrorDto {
    code?: string | null;
    description?: string | null;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IErrorDto {
    code?: string | null;
    description?: string | null;
}

export enum Measure {
    Unit = "Unit",
    Centimeters = "Centimeters",
    Meters = "Meters",
    Box = "Box",
    Kilometers = "Kilometers",
}

export class MessageInsert implements IMessageInsert {
    name?: string | null;
    email?: string | null;
    description?: string | null;

    constructor(data?: IMessageInsert) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): MessageInsert {
        data = typeof data === 'object' ? data : {};
        let result = new MessageInsert();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IMessageInsert {
    name?: string | null;
    email?: string | null;
    description?: string | null;
}

export class NotificationResponse implements INotificationResponse {
    id?: string;
    title?: string | null;
    body?: string | null;
    error?: string | null;
    inserted?: Date;
    state?: NotificationState;

    constructor(data?: INotificationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.inserted = _data["inserted"] ? new Date(_data["inserted"].toString()) : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
        }
    }

    static fromJS(data: any): NotificationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["body"] = this.body !== undefined ? this.body : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["inserted"] = this.inserted ? this.inserted.toISOString() : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        return data;
    }
}

export interface INotificationResponse {
    id?: string;
    title?: string | null;
    body?: string | null;
    error?: string | null;
    inserted?: Date;
    state?: NotificationState;
}

export enum NotificationState {
    New = "New",
    Read = "Read",
    Error = "Error",
}

export class OrderDetailResponse implements IOrderDetailResponse {
    id?: string;
    identifier?: number;
    amount?: number;
    inserted?: Date;
    pdfUrl?: string | null;

    constructor(data?: IOrderDetailResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.identifier = _data["identifier"] !== undefined ? _data["identifier"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.inserted = _data["inserted"] ? new Date(_data["inserted"].toString()) : <any>null;
            this.pdfUrl = _data["pdfUrl"] !== undefined ? _data["pdfUrl"] : <any>null;
        }
    }

    static fromJS(data: any): OrderDetailResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["identifier"] = this.identifier !== undefined ? this.identifier : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["inserted"] = this.inserted ? this.inserted.toISOString() : <any>null;
        data["pdfUrl"] = this.pdfUrl !== undefined ? this.pdfUrl : <any>null;
        return data;
    }
}

export interface IOrderDetailResponse {
    id?: string;
    identifier?: number;
    amount?: number;
    inserted?: Date;
    pdfUrl?: string | null;
}

export class OrderInsert implements IOrderInsert {
    clientId?: string | null;
    start?: Date;
    finish?: Date;
    note?: string | null;
    discount?: number;
    products?: OrderProductInsert[] | null;

    constructor(data?: IOrderInsert) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"] !== undefined ? _data["clientId"] : <any>null;
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>null;
            this.finish = _data["finish"] ? new Date(_data["finish"].toString()) : <any>null;
            this.note = _data["note"] !== undefined ? _data["note"] : <any>null;
            this.discount = _data["discount"] !== undefined ? _data["discount"] : <any>null;
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(OrderProductInsert.fromJS(item));
            }
            else {
                this.products = <any>null;
            }
        }
    }

    static fromJS(data: any): OrderInsert {
        data = typeof data === 'object' ? data : {};
        let result = new OrderInsert();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId !== undefined ? this.clientId : <any>null;
        data["start"] = this.start ? this.start.toISOString() : <any>null;
        data["finish"] = this.finish ? this.finish.toISOString() : <any>null;
        data["note"] = this.note !== undefined ? this.note : <any>null;
        data["discount"] = this.discount !== undefined ? this.discount : <any>null;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrderInsert {
    clientId?: string | null;
    start?: Date;
    finish?: Date;
    note?: string | null;
    discount?: number;
    products?: OrderProductInsert[] | null;
}

export class OrderPdfResponse implements IOrderPdfResponse {
    pdf?: string | null;
    fileName?: string | null;

    constructor(data?: IOrderPdfResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pdf = _data["pdf"] !== undefined ? _data["pdf"] : <any>null;
            this.fileName = _data["fileName"] !== undefined ? _data["fileName"] : <any>null;
        }
    }

    static fromJS(data: any): OrderPdfResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderPdfResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pdf"] = this.pdf !== undefined ? this.pdf : <any>null;
        data["fileName"] = this.fileName !== undefined ? this.fileName : <any>null;
        return data;
    }
}

export interface IOrderPdfResponse {
    pdf?: string | null;
    fileName?: string | null;
}

export class OrderProductInsert implements IOrderProductInsert {
    id?: string | null;
    measure?: Measure;
    unitaryValue?: number;
    amount?: number;
    description?: string | null;
    readonly isNew?: boolean;
    readonly subtotal?: number;

    constructor(data?: IOrderProductInsert) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.measure = _data["measure"] !== undefined ? _data["measure"] : <any>null;
            this.unitaryValue = _data["unitaryValue"] !== undefined ? _data["unitaryValue"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            (<any>this).isNew = _data["isNew"] !== undefined ? _data["isNew"] : <any>null;
            (<any>this).subtotal = _data["subtotal"] !== undefined ? _data["subtotal"] : <any>null;
        }
    }

    static fromJS(data: any): OrderProductInsert {
        data = typeof data === 'object' ? data : {};
        let result = new OrderProductInsert();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["measure"] = this.measure !== undefined ? this.measure : <any>null;
        data["unitaryValue"] = this.unitaryValue !== undefined ? this.unitaryValue : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["isNew"] = this.isNew !== undefined ? this.isNew : <any>null;
        data["subtotal"] = this.subtotal !== undefined ? this.subtotal : <any>null;
        return data;
    }
}

export interface IOrderProductInsert {
    id?: string | null;
    measure?: Measure;
    unitaryValue?: number;
    amount?: number;
    description?: string | null;
    isNew?: boolean;
    subtotal?: number;
}

export class OrderResponse implements IOrderResponse {
    id?: string;
    client?: ClientResponse;
    identifier?: number;
    amount?: number;
    discount?: number;
    start?: Date;
    finish?: Date;
    note?: string | null;
    state?: OrderState;
    inserted?: Date;

    constructor(data?: IOrderResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.client = _data["client"] ? ClientResponse.fromJS(_data["client"]) : <any>null;
            this.identifier = _data["identifier"] !== undefined ? _data["identifier"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.discount = _data["discount"] !== undefined ? _data["discount"] : <any>null;
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>null;
            this.finish = _data["finish"] ? new Date(_data["finish"].toString()) : <any>null;
            this.note = _data["note"] !== undefined ? _data["note"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.inserted = _data["inserted"] ? new Date(_data["inserted"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): OrderResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["client"] = this.client ? this.client.toJSON() : <any>null;
        data["identifier"] = this.identifier !== undefined ? this.identifier : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["discount"] = this.discount !== undefined ? this.discount : <any>null;
        data["start"] = this.start ? this.start.toISOString() : <any>null;
        data["finish"] = this.finish ? this.finish.toISOString() : <any>null;
        data["note"] = this.note !== undefined ? this.note : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["inserted"] = this.inserted ? this.inserted.toISOString() : <any>null;
        return data;
    }
}

export interface IOrderResponse {
    id?: string;
    client?: ClientResponse;
    identifier?: number;
    amount?: number;
    discount?: number;
    start?: Date;
    finish?: Date;
    note?: string | null;
    state?: OrderState;
    inserted?: Date;
}

export enum OrderState {
    None = "None",
    Pay = "Pay",
}

export enum Person {
    Physical = "Physical",
    Legal = "Legal",
    Unknown = "Unknown",
}

export class ProblemDetails implements IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.detail = _data["detail"] !== undefined ? _data["detail"] : <any>null;
            this.instance = _data["instance"] !== undefined ? _data["instance"] : <any>null;
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["detail"] = this.detail !== undefined ? this.detail : <any>null;
        data["instance"] = this.instance !== undefined ? this.instance : <any>null;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;

    [key: string]: any;
}

export class ProductInsert implements IProductInsert {
    measure?: Measure;
    unitaryValue?: number;
    description?: string | null;

    constructor(data?: IProductInsert) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.measure = _data["measure"] !== undefined ? _data["measure"] : <any>null;
            this.unitaryValue = _data["unitaryValue"] !== undefined ? _data["unitaryValue"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): ProductInsert {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInsert();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["measure"] = this.measure !== undefined ? this.measure : <any>null;
        data["unitaryValue"] = this.unitaryValue !== undefined ? this.unitaryValue : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IProductInsert {
    measure?: Measure;
    unitaryValue?: number;
    description?: string | null;
}

export class ProductResponse implements IProductResponse {
    id?: string;
    measure?: Measure;
    unitaryValue?: number;
    description?: string | null;
    readonly inserted?: Date;

    constructor(data?: IProductResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.measure = _data["measure"] !== undefined ? _data["measure"] : <any>null;
            this.unitaryValue = _data["unitaryValue"] !== undefined ? _data["unitaryValue"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            (<any>this).inserted = _data["inserted"] ? new Date(_data["inserted"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): ProductResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["measure"] = this.measure !== undefined ? this.measure : <any>null;
        data["unitaryValue"] = this.unitaryValue !== undefined ? this.unitaryValue : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["inserted"] = this.inserted ? this.inserted.toISOString() : <any>null;
        return data;
    }
}

export interface IProductResponse {
    id?: string;
    measure?: Measure;
    unitaryValue?: number;
    description?: string | null;
    inserted?: Date;
}

export class ProductUpdate implements IProductUpdate {
    id?: string;
    measure?: Measure;
    unitaryValue?: number;
    description?: string | null;

    constructor(data?: IProductUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.measure = _data["measure"] !== undefined ? _data["measure"] : <any>null;
            this.unitaryValue = _data["unitaryValue"] !== undefined ? _data["unitaryValue"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): ProductUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new ProductUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["measure"] = this.measure !== undefined ? this.measure : <any>null;
        data["unitaryValue"] = this.unitaryValue !== undefined ? this.unitaryValue : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IProductUpdate {
    id?: string;
    measure?: Measure;
    unitaryValue?: number;
    description?: string | null;
}

export class UserNotificationResponse implements IUserNotificationResponse {
    id?: string;
    title?: string | null;
    description?: string | null;
    icon?: string | null;
    createdAt?: Date;
    isUnRead?: boolean;

    constructor(data?: IUserNotificationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.icon = _data["icon"] !== undefined ? _data["icon"] : <any>null;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
            this.isUnRead = _data["isUnRead"] !== undefined ? _data["isUnRead"] : <any>null;
        }
    }

    static fromJS(data: any): UserNotificationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotificationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["icon"] = this.icon !== undefined ? this.icon : <any>null;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>null;
        data["isUnRead"] = this.isUnRead !== undefined ? this.isUnRead : <any>null;
        return data;
    }
}

export interface IUserNotificationResponse {
    id?: string;
    title?: string | null;
    description?: string | null;
    icon?: string | null;
    createdAt?: Date;
    isUnRead?: boolean;
}

export class UserResponse implements IUserResponse {
    id?: string;
    privacyPolicyAccepted?: boolean;
    pushNotificationToken?: string | null;
    addPictureInOrder?: boolean;
    name?: string | null;
    nameFull?: string | null;
    email?: string | null;
    address?: string | null;
    document?: string | null;
    city?: string | null;
    telephone?: string | null;
    state?: string | null;
    cellphone?: string | null;
    pictureUrl?: string | null;
    roles?: string[] | null;
    notifications?: UserNotificationResponse[] | null;

    constructor(data?: IUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.privacyPolicyAccepted = _data["privacyPolicyAccepted"] !== undefined ? _data["privacyPolicyAccepted"] : <any>null;
            this.pushNotificationToken = _data["pushNotificationToken"] !== undefined ? _data["pushNotificationToken"] : <any>null;
            this.addPictureInOrder = _data["addPictureInOrder"] !== undefined ? _data["addPictureInOrder"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.nameFull = _data["nameFull"] !== undefined ? _data["nameFull"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.address = _data["address"] !== undefined ? _data["address"] : <any>null;
            this.document = _data["document"] !== undefined ? _data["document"] : <any>null;
            this.city = _data["city"] !== undefined ? _data["city"] : <any>null;
            this.telephone = _data["telephone"] !== undefined ? _data["telephone"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.cellphone = _data["cellphone"] !== undefined ? _data["cellphone"] : <any>null;
            this.pictureUrl = _data["pictureUrl"] !== undefined ? _data["pictureUrl"] : <any>null;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            else {
                this.roles = <any>null;
            }
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(UserNotificationResponse.fromJS(item));
            }
            else {
                this.notifications = <any>null;
            }
        }
    }

    static fromJS(data: any): UserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["privacyPolicyAccepted"] = this.privacyPolicyAccepted !== undefined ? this.privacyPolicyAccepted : <any>null;
        data["pushNotificationToken"] = this.pushNotificationToken !== undefined ? this.pushNotificationToken : <any>null;
        data["addPictureInOrder"] = this.addPictureInOrder !== undefined ? this.addPictureInOrder : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nameFull"] = this.nameFull !== undefined ? this.nameFull : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["document"] = this.document !== undefined ? this.document : <any>null;
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["telephone"] = this.telephone !== undefined ? this.telephone : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["cellphone"] = this.cellphone !== undefined ? this.cellphone : <any>null;
        data["pictureUrl"] = this.pictureUrl !== undefined ? this.pictureUrl : <any>null;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserResponse {
    id?: string;
    privacyPolicyAccepted?: boolean;
    pushNotificationToken?: string | null;
    addPictureInOrder?: boolean;
    name?: string | null;
    nameFull?: string | null;
    email?: string | null;
    address?: string | null;
    document?: string | null;
    city?: string | null;
    telephone?: string | null;
    state?: string | null;
    cellphone?: string | null;
    pictureUrl?: string | null;
    roles?: string[] | null;
    notifications?: UserNotificationResponse[] | null;
}

export class UserUpdate implements IUserUpdate {
    id?: string;
    name?: string | null;
    nameFull?: string | null;
    address?: string | null;
    document?: string | null;
    city?: string | null;
    telephone?: string | null;
    state?: string | null;
    cellphone?: string | null;
    picture?: string | null;
    addPictureInOrder?: boolean;

    constructor(data?: IUserUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.nameFull = _data["nameFull"] !== undefined ? _data["nameFull"] : <any>null;
            this.address = _data["address"] !== undefined ? _data["address"] : <any>null;
            this.document = _data["document"] !== undefined ? _data["document"] : <any>null;
            this.city = _data["city"] !== undefined ? _data["city"] : <any>null;
            this.telephone = _data["telephone"] !== undefined ? _data["telephone"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.cellphone = _data["cellphone"] !== undefined ? _data["cellphone"] : <any>null;
            this.picture = _data["picture"] !== undefined ? _data["picture"] : <any>null;
            this.addPictureInOrder = _data["addPictureInOrder"] !== undefined ? _data["addPictureInOrder"] : <any>null;
        }
    }

    static fromJS(data: any): UserUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new UserUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["nameFull"] = this.nameFull !== undefined ? this.nameFull : <any>null;
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["document"] = this.document !== undefined ? this.document : <any>null;
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["telephone"] = this.telephone !== undefined ? this.telephone : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["cellphone"] = this.cellphone !== undefined ? this.cellphone : <any>null;
        data["picture"] = this.picture !== undefined ? this.picture : <any>null;
        data["addPictureInOrder"] = this.addPictureInOrder !== undefined ? this.addPictureInOrder : <any>null;
        return data;
    }
}

export interface IUserUpdate {
    id?: string;
    name?: string | null;
    nameFull?: string | null;
    address?: string | null;
    document?: string | null;
    city?: string | null;
    telephone?: string | null;
    state?: string | null;
    cellphone?: string | null;
    picture?: string | null;
    addPictureInOrder?: boolean;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}